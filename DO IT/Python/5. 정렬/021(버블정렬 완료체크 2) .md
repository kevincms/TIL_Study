제안시간은 1초여서 2천만번(2*10<sup>7</sup>)의 연산이 가능하고 수의 개수는 5십만개(5*10<sup>5</sup>)이다
이 문제는 16번 버블정렬 완료체크 1 과 유사한 문제이다.
16번의 경우 아직 병합정렬을 공부하지 않았기에 내장 정렬 함수인 sort 사용했다.
이번에는 내장 정렬 함수인 sort를 사용하지 않고 병합정렬을 이용할 것이다.

16번의 경우 swap이 일어나는 루프의 횟수를 구하는 것이었지만 이번에는 swap의 개수를 모두 구해야 한다.
근데 어려워서 일단 sort 쓴다음 해야겠다. ㅎㅎ

swap이 일어난 경우를 생각해보면 정렬된 배열과 정렬되지 않은 배열의 인덱스의 차이를 합을 더한 것이다.
하지만 그 과정에서 중복된 swap이 있으므로 그것의 수를 빼주어야 한다.
근데 틀렸다. 같은 숫자가 있을 경우 인덱스를 비교해보아야 할 것 같다.

중복을 체크하는 방식이 틀렸던 것 같음.
4 3 2 1 <!-- 정렬되지 않은 배열 -->
1 2 3 4 <!-- 정렬된 배열 -->
3 1 1 3 <!-- 정렬된 배열과 정렬되지 않은 배열의 인덱스 차이 -->
4-1 : 1 <!-- 중복된 경우 1 -->
3-2 : 1 <!-- 중복된 경우 2 -->
3+3+1+1-2=6

3 3 1 <!-- 정렬되지 않은 배열 -->
1 3 3 <!-- 정렬된 배열 -->
2 1 1 <!-- 정렬된 배열과 정렬되지 않은 배열의 인덱스 차이-->

2 0 2 <!-- 주의 숫자가 같더라도 들어온 순서가 다르기 때문에 이와 같은 경우는 안됨-->

3(1)-1 : 1 <!-- 중복된 경우 1 (첫번째로 입력된 3) -->
3(2)-1 : 1 <!-- 중복된 경우 2 (두번째로 입력된 3) -->
2+2-2=2

오름차순으로 정렬할 때 뒤에서 앞으로 오는 숫자와 앞에서 뒤로 가는 숫자의 경로를 리스트에 0 과 1 로 표한하고
and 연산을 한 뒤 1이 나오면 중복된 개수가 있는 것으로 간주할 수 있을 것 같음.